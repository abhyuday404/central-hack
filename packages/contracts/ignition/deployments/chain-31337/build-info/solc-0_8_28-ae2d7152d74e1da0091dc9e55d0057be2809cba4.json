{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-ae2d7152d74e1da0091dc9e55d0057be2809cba4",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/MedicalRecord.sol": "project/contracts/MedicalRecord.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/MedicalRecord.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\ncontract MedicalRecord {\r\n    // Define what a \"Record\" looks like\r\n    struct Record {\r\n        string ipfsHash; // The \"fingerprint\" of the file stored on Pinata\r\n        string fileName; // Readable name (e.g., \"X-Ray Chest\")\r\n        address doctor; // Who uploaded it\r\n        uint256 timestamp; // When it was uploaded\r\n    }\r\n\r\n    enum RequestStatus {\r\n        Pending,\r\n        Approved,\r\n        Rejected\r\n    }\r\n\r\n    struct AccessRequest {\r\n        address requester;\r\n        uint256 timestamp;\r\n        RequestStatus status;\r\n        uint256 durationInHours; // How long access is requested for\r\n        uint256 grantedAt; // When access was granted (0 if not yet)\r\n        uint256 expiresAt; // When access expires (0 if not yet granted)\r\n    }\r\n\r\n    // Map a Patient's Wallet Address -> List of their Records\r\n    mapping(address => Record[]) private patientRecords;\r\n\r\n    // Map a Patient -> Requests\r\n    mapping(address => AccessRequest[]) private accessRequests;\r\n\r\n    // Map a Patient -> Requester -> Access expiry timestamp (0 = no access)\r\n    mapping(address => mapping(address => uint256)) private accessExpiry;\r\n\r\n    // Events help your frontend know when something happened\r\n    event RecordAdded(\r\n        address indexed patient,\r\n        string ipfsHash,\r\n        address indexed doctor\r\n    );\r\n    event AccessRequested(\r\n        address indexed patient,\r\n        address indexed requester,\r\n        uint256 requestId,\r\n        uint256 durationInHours\r\n    );\r\n    event AccessRequestResolved(\r\n        address indexed patient,\r\n        address indexed requester,\r\n        uint256 requestId,\r\n        bool approved,\r\n        uint256 expiresAt\r\n    );\r\n    event AccessRevoked(address indexed patient, address indexed requester);\r\n    event AccessExtended(\r\n        address indexed patient,\r\n        address indexed requester,\r\n        uint256 newExpiresAt\r\n    );\r\n\r\n    // Check if a requester currently has valid (non-expired) access to a patient's records\r\n    function hasAccess(\r\n        address _patient,\r\n        address _requester\r\n    ) public view returns (bool) {\r\n        // Patient always has access to their own records\r\n        if (_requester == _patient) return true;\r\n        // Check if access is granted and not expired\r\n        uint256 expiry = accessExpiry[_patient][_requester];\r\n        return expiry > 0 && block.timestamp <= expiry;\r\n    }\r\n\r\n    // Get the expiry timestamp for a requester's access to a patient's records\r\n    function getAccessExpiry(\r\n        address _patient,\r\n        address _requester\r\n    ) public view returns (uint256) {\r\n        if (_requester == _patient) return type(uint256).max; // Patient always has access\r\n        return accessExpiry[_patient][_requester];\r\n    }\r\n\r\n    // Get remaining seconds of access (0 if expired or no access)\r\n    function getRemainingAccess(\r\n        address _patient,\r\n        address _requester\r\n    ) public view returns (uint256) {\r\n        if (_requester == _patient) return type(uint256).max;\r\n        uint256 expiry = accessExpiry[_patient][_requester];\r\n        if (expiry == 0 || block.timestamp > expiry) return 0;\r\n        return expiry - block.timestamp;\r\n    }\r\n\r\n    // Request access to a patient's records with a specified duration\r\n    function requestAccess(\r\n        address _patient,\r\n        uint256 _durationInHours\r\n    ) public returns (uint256 requestId) {\r\n        require(_patient != address(0), \"Invalid patient\");\r\n        require(_durationInHours > 0, \"Duration must be > 0\");\r\n        require(\r\n            _durationInHours <= 8760,\r\n            \"Max duration is 1 year (8760 hours)\"\r\n        );\r\n        require(msg.sender != _patient, \"Cannot request access to own records\");\r\n\r\n        AccessRequest memory request = AccessRequest({\r\n            requester: msg.sender,\r\n            timestamp: block.timestamp,\r\n            status: RequestStatus.Pending,\r\n            durationInHours: _durationInHours,\r\n            grantedAt: 0,\r\n            expiresAt: 0\r\n        });\r\n\r\n        accessRequests[_patient].push(request);\r\n        requestId = accessRequests[_patient].length - 1;\r\n\r\n        emit AccessRequested(_patient, msg.sender, requestId, _durationInHours);\r\n    }\r\n\r\n    // Patient reviews their access requests\r\n    function getRequests(\r\n        address _patient\r\n    ) public view returns (AccessRequest[] memory) {\r\n        require(msg.sender == _patient, \"Only patient\");\r\n        return accessRequests[_patient];\r\n    }\r\n\r\n    // Patient approves or rejects an access request\r\n    function respondToRequest(uint256 _requestId, bool _approve) public {\r\n        require(\r\n            _requestId < accessRequests[msg.sender].length,\r\n            \"Invalid request ID\"\r\n        );\r\n        AccessRequest storage request = accessRequests[msg.sender][_requestId];\r\n        require(request.requester != address(0), \"Invalid request\");\r\n        require(request.status == RequestStatus.Pending, \"Already resolved\");\r\n\r\n        uint256 expiresAt = 0;\r\n\r\n        if (_approve) {\r\n            request.status = RequestStatus.Approved;\r\n            request.grantedAt = block.timestamp;\r\n            expiresAt = block.timestamp + (request.durationInHours * 1 hours);\r\n            request.expiresAt = expiresAt;\r\n            accessExpiry[msg.sender][request.requester] = expiresAt;\r\n        } else {\r\n            request.status = RequestStatus.Rejected;\r\n        }\r\n\r\n        emit AccessRequestResolved(\r\n            msg.sender,\r\n            request.requester,\r\n            _requestId,\r\n            _approve,\r\n            expiresAt\r\n        );\r\n    }\r\n\r\n    // Patient can revoke access at any time, even before expiry\r\n    function revokeAccess(address _requester) public {\r\n        require(_requester != address(0), \"Invalid requester\");\r\n        require(\r\n            accessExpiry[msg.sender][_requester] > 0,\r\n            \"No access to revoke\"\r\n        );\r\n\r\n        accessExpiry[msg.sender][_requester] = 0;\r\n\r\n        emit AccessRevoked(msg.sender, _requester);\r\n    }\r\n\r\n    // Patient can extend an existing access grant\r\n    function extendAccess(address _requester, uint256 _additionalHours) public {\r\n        require(_requester != address(0), \"Invalid requester\");\r\n        require(_additionalHours > 0, \"Additional hours must be > 0\");\r\n\r\n        uint256 currentExpiry = accessExpiry[msg.sender][_requester];\r\n        require(currentExpiry > 0, \"No existing access to extend\");\r\n\r\n        uint256 baseTime = block.timestamp > currentExpiry\r\n            ? block.timestamp\r\n            : currentExpiry;\r\n        uint256 newExpiry = baseTime + (_additionalHours * 1 hours);\r\n\r\n        // Ensure extended access doesn't exceed 1 year from now\r\n        require(\r\n            newExpiry <= block.timestamp + (8760 * 1 hours),\r\n            \"Cannot extend beyond 1 year\"\r\n        );\r\n\r\n        accessExpiry[msg.sender][_requester] = newExpiry;\r\n\r\n        emit AccessExtended(msg.sender, _requester, newExpiry);\r\n    }\r\n\r\n    // Get all active (non-expired) accessors for a patient\r\n    // Uses a two-pass approach: first collects unique addresses, then filters active ones\r\n    function getActiveAccessors(\r\n        address _patient\r\n    ) public view returns (address[] memory, uint256[] memory) {\r\n        require(msg.sender == _patient, \"Only patient\");\r\n\r\n        AccessRequest[] storage requests = accessRequests[_patient];\r\n        uint256 len = requests.length;\r\n\r\n        if (len == 0) {\r\n            return (new address[](0), new uint256[](0));\r\n        }\r\n\r\n        // Collect unique requesters with active access in one pass (reverse for latest-first dedup)\r\n        address[] memory temp = new address[](len);\r\n        uint256[] memory tempExp = new uint256[](len);\r\n        uint256 count = 0;\r\n\r\n        for (uint256 i = len; i > 0; i--) {\r\n            address req = requests[i - 1].requester;\r\n            uint256 expiry = accessExpiry[_patient][req];\r\n\r\n            // Skip if no active access\r\n            if (expiry == 0 || block.timestamp > expiry) continue;\r\n\r\n            // Skip if we already recorded this requester (dedup)\r\n            bool found = false;\r\n            for (uint256 j = 0; j < count; j++) {\r\n                if (temp[j] == req) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (found) continue;\r\n\r\n            temp[count] = req;\r\n            tempExp[count] = expiry;\r\n            count++;\r\n        }\r\n\r\n        // Copy into correctly-sized arrays\r\n        address[] memory addrs = new address[](count);\r\n        uint256[] memory expiries = new uint256[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            addrs[i] = temp[i];\r\n            expiries[i] = tempExp[i];\r\n        }\r\n\r\n        return (addrs, expiries);\r\n    }\r\n\r\n    // Upload a record (Only creates the link, doesn't store the file)\r\n    function addRecord(\r\n        address _patient,\r\n        string memory _ipfsHash,\r\n        string memory _fileName\r\n    ) public {\r\n        require(hasAccess(_patient, msg.sender), \"Not authorized\");\r\n\r\n        Record memory newRecord = Record({\r\n            ipfsHash: _ipfsHash,\r\n            fileName: _fileName,\r\n            doctor: msg.sender,\r\n            timestamp: block.timestamp\r\n        });\r\n\r\n        patientRecords[_patient].push(newRecord);\r\n\r\n        emit RecordAdded(_patient, _ipfsHash, msg.sender);\r\n    }\r\n\r\n    // View a patient's records (only if access is valid and not expired)\r\n    function getRecords(\r\n        address _patient\r\n    ) public view returns (Record[] memory) {\r\n        require(hasAccess(_patient, msg.sender), \"Not authorized\");\r\n        return patientRecords[_patient];\r\n    }\r\n}\r\n"
      }
    }
  }
}